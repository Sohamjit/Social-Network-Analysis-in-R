---
title: "Social Network Analysis - Final Assignment"
author: "Sohamjit Mukherjee"
date: "15 March 2019"
output: html_document

---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

<span style="color:blue"> The source of the data can be found through the following link: http://networkdata.ics.uci.edu/netdata/html/floridaFoodWebs.html 

<span style="color:blue"> The data consists of networks of carbon exchange as they normally occur in the ecosystem of South Florida. Separate networks for wet and dry seasons are present for the ecosystems of the cypress wetlands, the Everglades gramminoid marshes, the mangrove estuaries, and the shallows of Florida Bay. Vertices in these networks represent major components of the ecosystem, and edges represent the tranfers of material or energy between the components.

<span style="color:blue"> Some animals overpopulate certain regions of the world whereas other species are endangered in others. This causes threat for our environment and ecosystem. It is a well known fact that Florida suffers from an overpopulation of alligators and snakes. Nevertheless, the approaches taken to control overpopulations focus on killing, catching or poisoning the overpopulated species. The measures taken to save endangered species have a rather limited scope as well. NGOs and governments often do not have the tools and resources to engage in an in-depth analysis. This project will help governments, NGOs and other organizations to understand the roles of certain animals within an ecosystem through the eyes of a Social Network Analysis. The goal is make the previously mentioned groups aware of the key issues in order to develop customized measures to combat overpopulation as well as help endangered species. We want to provide a kind of interactive platform that can be updated with current data.

<span style="color:blue"> For our analysis, we will start with the Cypress Wetlands area of the south Florida region and try to compare how the carbon exchange between dry and wet season changes. Moreover, we will analyze the interactions among the different animals. It deserves to mention that our overall analysis will focus on  interactions of animals.

In this Rmarkdown file,

<span style="color:blue"> All the insights & findings have been written in blue

<span style="color:orange"> All the technical comments have been made in orange

## Loading the Packages

<span style="color:orange"> Let us start by clearing the workspace and installing the required libraries. "SuppressMessages" in the code helps us to not display the unnecessary messages during the installation process.

```{r, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, fig.showtext=FALSE}

rm(list=ls())

if(!require(data.table)){
    install.packages("data.table")
    suppressMessages(library(data.table))
}

if(!require(igraph)){
    install.packages("igraph")
    suppressMessages(library(igraph))
}

if(!require(stringr)){
    install.packages("stringr")
    suppressMessages(library(stringr))
}


if(!require(shiny)){
    install.packages("shiny")
    suppressMessages(library(shiny))
}

if(!require(tidyr)){
    install.packages("tidyr")
    suppressMessages(library(tidyr))
}

if(!require(ggplot2)){
    install.packages("ggplot2")
    suppressMessages(library(ggplot2))
}

if(!require(networkD3)){
    install.packages("networkD3")
    suppressMessages(library(networkD3))
}

if(!require(gridExtra)){
    install.packages("gridExtra")
    suppressMessages(library(gridExtra))
}

if(!require(intergraph)){
    install.packages("intergraph")
    suppressMessages(library(intergraph))
}

if(!require(networkD3)){
    install.packages("networkD3")
    suppressMessages(library(networkD3))
}

if(!require(network)){
    install.packages("network")
    suppressMessages(library(network))
}


if(!require(visNetwork)){
    install.packages("visNetwork")
    suppressMessages(library(visNetwork))
}

if(!require(ggraph)){
    install.packages("ggraph")
    suppressMessages(library(ggraph))
}

```

## Load the Dataset

<span style="color:orange"> Load the original dataset. The .Rdata file needs to be in the same location as that of the this Rmarkdown file. The data can be downloaded from this location : 
http://networkdata.ics.uci.edu/netdata/html/floridaFoodWebs.html 

```{r}

load("floridaFoodWebs.Rdata")

```

### Data Type Conversion From Network to Igraph data type

<span style="color:orange"> Now, the dataset we loaded is of the data type "network". We will convert this data type into "igraph" format. For doing this we will use the library intergraph.

```{r}

CypDry = asIgraph(cypDry)
CypWet = asIgraph(cypWet)

```

<span style="color:orange"> As previously mentioned we will for now only work with the data set Cypress Wetlands (dry and wet season).

## Exploratory Data Analysis

### Overall Summary

<span style="color:blue"> Let us quickly get an overview of both of the networks.

```{r}

print(cypDry)
print(cypWet)

```

<span style="color:blue"> A quick overview of the datasets provides us with the following information :

<span style="color:blue"> We would like to provide some background information related to the terms "dry season" and "wet season". 
<span style="color:blue"> The "wet season" mainly refers to the period from May through October and is characterized by high temperatures (>30 Celsius)/humidity. Besides, this season produces the majority of the region's average rainfall. 
<span style="color:blue"> The so called "dry season" runs from December to mid-May and is characterized by low humidity levels and temperatures between 10-25 Celsius. It deserves to mention that around 20% of the region's average annual rain falls during this time of the year.

<span style="color:blue"> In the following paragraphs we will provide some dataset specific information. For example, we can conclude that there are a total 71 vertices (71 different animals) in the wet and dry seasons.

<span style="color:blue"> The graph is a directed one without any loops. There are a total of 640 edges in the dry season wherease the number of edges reduces to 631 during wet season. There are no missing edges in both seasons.

### Plot Overall Dataset - An Interactive Visualization with VisNetwork 


<span style="color:blue"> We will use the "visnetwork" library to plot and get an idea of the overall network. This is an interactive graph and will consume a lot of memory. In case the memory of the computer is not sufficient, the computer might not be able to generate the HTML file. In that case, our advice will be to run the code chunk sepearetely in the Rmarkdown file.

```{r, fig.width=16, fig.height=14}

# Preparing the node data frame by extracting names and groups from the graph

nodes <- data.frame(id = V(CypDry)$vertex.names ,title = V(CypDry)$vertex.names, group = V(CypDry)$ECO.type)
nodes <- nodes[order(nodes$id, decreasing = T),]

# Creating nodes id

nodes$Seq = seq(nrow(nodes))

# Preparing the edge data frame by extracting the edges information from the data set

edges <- get.data.frame(CypDry, what="edges")[1:2]
edges$from =nodes$id[match(edges$from,nodes$Seq)]
edges$to =nodes$id[match(edges$to,nodes$Seq)]

# Plot the graph

visNetwork(nodes,edges , width = "100%", main = "Networks in the Cypress Wetlands Dry Season") %>%
  visOptions(highlightNearest = T, nodesIdSelection = T)%>%
  visGroups(groupname = "2", color = "red") %>%
  visLegend(useGroups = T, addNodes = data.frame(label = "Nodes", shape = "circle"), 
            addEdges = data.frame(label = "link", color = "green")) %>%
  visEdges(shadow = TRUE,
           arrows =list(to = list(enabled = TRUE, scaleFactor = 2)),
           color = list(color = "lightgreen", highlight = "red"))


```

<span style="color:blue"> The above shown graph provides us with a general overview of the networks in the Cypress Wetlands Dry Season. The 5 different colors represent the 5 different groups (Blue: Living/producing compartment, Red: Other compartment, Green: Input, Light-red: Output, Yellow: Respiration ). The filter option ("detail-on-demand") alllows us to have a closer look at some of the animals. This in turn shifts the scope from a broad perspective to a narrow one. For example, the applied filter for alligators illustrates the different connections of alligators. Nevertheless, at this stage we do not make the distinction between directed and undirected graphs. The overall purpose of this interactive visualization is to develop a thorough understanding for the networks of the different animals during the "Dry Season". This approach is well in line with the general guidlines of an EDA.

<span style="color:blue"> The below shown graphic illustrates the same concept for the wet season.

```{r, fig.width=16, fig.height=14}

# Preparing the node data frame by extracting names and group from the graph

nodes <- data.frame(id = V(CypWet)$vertex.names ,title = V(CypWet)$vertex.names, group = V(CypWet)$ECO.type)
nodes <- nodes[order(nodes$id, decreasing = T),]

# Creating nodes id

nodes$Seq = seq(nrow(nodes))

# Preparing the edge data frame by extracting the edges information from the data set

edges <- get.data.frame(CypDry, what="edges")[1:2]
edges$from =nodes$id[match(edges$from,nodes$Seq)]
edges$to =nodes$id[match(edges$to,nodes$Seq)]

# Plot the graph

visNetwork(nodes,edges , width = "100%", main = "Networks in the Cypress Wetlands Dry Season") %>%
  visOptions(highlightNearest = T, nodesIdSelection = T)%>%
  visGroups(groupname = "2", color = "red") %>%
  visLegend(useGroups = T, addNodes = data.frame(label = "Nodes", shape = "circle"), 
            addEdges = data.frame(label = "link", color = "green")) %>%
  visEdges(shadow = TRUE,
           arrows =list(to = list(enabled = TRUE, scaleFactor = 2)),
           color = list(color = "lightgreen", highlight = "red"))


```


### Overall Degree Distribution 

<span style="color:blue"> The degree disitribution gives us a good overview of the position of animals within the ecosystem. For example, who are the natural enemies of a specific species? We sticked to the following 3 steps in order to derive to our conlcusions:

<span style="color:orange"> 1) Degree distribution with mode out (only for out degree) - Compare the animals whose out degree changes in between the wet and dry season. The out degree shows what kind of animals are predators. For example, the out degress of an alligator show the preferred food of alligators.
  <span style="color:orange"> 2) Degree distribution with mode in (only for in degree) - Compare the animals whose in degree changes in between the wet and dry seasons. Animals with many in degrees are in danger because they are the preferred food of many other predators.
  <span style="color:orange"> 3) Degree distribution with mode all (sum of both the in and out degrees)

#### Cypress Wetlands Dry & Wet Season Comparison - Out Degree

```{r  warning= F , message=F , fig.width=16}

# Calculate the out degree.

cypDry_Degree = as.data.table(degree(CypDry, mode = "out"))

cypWet_Degree = as.data.table(degree(CypWet, mode = "out"))

# Plot the degree distribution.

Plot1 = ggplot(data=cypDry_Degree, aes(cypDry_Degree$V1)) + 
       geom_histogram(col = "black", fill= "turquoise") +
       theme_classic() +
       ggtitle("Cypress Wetlands Dry Season (Out Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

Plot2 = ggplot(data=cypWet_Degree, aes(cypWet_Degree$V1)) + 
       geom_histogram(col = "black", fill= "turquoise") +
       theme_classic() +
       ggtitle("Cypress Wetlands Wet Season (Out Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

# Use the library fucntion grid arrange to compare the graphs side by side.

grid.arrange(Plot1, Plot2, nrow = 1)


# Lets also see how the cumulative distribution looks like.

Deg_Dist_Dry = degree_distribution(CypDry, cumulative=T, mode="out")

Plot3 = plot( x=0:max(cypDry_Degree), y=1-Deg_Dist_Dry, pch=19, cex=1.2, col="orange", main ="Cypress Wetlands Dry Season (Out Degree)",
xlab="Degree", ylab="Cumulative Frequency")

Deg_Dist_Wet = degree_distribution(CypWet, cumulative=T, mode="out")

Plot4 = plot( x=0:max(cypWet_Degree), y=1-Deg_Dist_Wet, pch=19, cex=1.2, col="blue", main ="Cypress Wetlands Wet Season (Out Degree)",
xlab="Degree", ylab="Cumulative Frequency")


```

<span style="color:blue"> By comparing the out degrees in the wet and in the dry season, we can infer that the overall distribution has remained almost the same. However, there are some small differences which may not be explicitly visible to the bare eye.

<span style="color:blue"> We want to shed further light on the previously mentioned "small differences" and decided to compare only those animals that show a change in degree between the different seasons (wet and dry season).

```{r , warning= F , message=F, fig.width=16}

# Merge the out degree for wet and dry season together.

Df = cbind(cypWet_Degree , cypDry_Degree)

# Assign column names.
names(Df) = c("Out Degree - Wet Season", "Out Degree - Dry Season")

# Create one unique identifier.

Df$Identifier <- seq.int(nrow(Df))

# Extract only those rows where the degrees do not match in wet and dry season.

Df = Df[which(Df[,1]!=Df[,2])]

Df = cbind(vertex_attr(CypWet, name="vertex.names", index =Df$Identifier) , Df[,1], Df[,2])

names(Df) = c("Animals", "Out Degree - Wet Season", "Out Degree - Dry Season")

Df

```

<span style="color:blue"> The above is the list of only those animals that changed their out degrees between the Dry and Wet season.

#### Cypress Wetlands Dry & Wet Season Comparison - In Degree


```{r  warning= F , message=F , fig.width= 16}

# Calculate the out degree.

cypDry_Degree = as.data.table(degree(CypDry, mode = "in"))

cypWet_Degree = as.data.table(degree(CypWet, mode = "in"))

# Plot the degree distribution.

Plot1 = ggplot(data=cypDry_Degree, aes(cypDry_Degree$V1)) + 
       geom_histogram(col = "black", fill= "green") +
       theme_classic() +
       ggtitle("Cypress Wetlands Dry Season (In Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

Plot2 = ggplot(data=cypWet_Degree, aes(cypWet_Degree$V1)) + 
       geom_histogram(col = "black", fill= "green") +
       theme_classic() +
       ggtitle("Cypress Wetlands Wet Season (In Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

# Use the library fucntion grid arrange to compare the graphs side by side.

grid.arrange(Plot1, Plot2, nrow = 1)


# Lets also see how the cumulative distribution looks like.

Deg_Dist_Dry = degree_distribution(CypDry, cumulative=T, mode="in")

Plot3 = plot( x=0:max(cypDry_Degree), y=1-Deg_Dist_Dry, pch=19, cex=1.2, col="orange", main ="Cypress Wetlands Dry Season (In Degree)",
xlab="Degree", ylab="Cumulative Frequency")

Deg_Dist_Wet = degree_distribution(CypWet, cumulative=T, mode="in")

Plot4 = plot( x=0:max(cypWet_Degree), y=1-Deg_Dist_Wet, pch=19, cex=1.2, col="blue", main ="Cypress Wetlands Wet Season (In Degree)",
xlab="Degree", ylab="Cumulative Frequency")




```

<span style="color:blue"> The findings of the "in-degrees" are very similar to the findings of the "out-degrees" and this outcome is in line with our expectations. Most distributions have remained stable except for some distributions with minor changes (e.g. snakes). For example, there are 3 animals that have more than 20 "in degrees" in the dry seasons but only 2 animals that have more than 20 "in-degrees" in the wet seasons. The differences can probably be partially attributed to the different weather conditions and breeding habits.  

<span style="color:blue"> Similarly, we will get the list of those animals for whom we see a change in degree during the dry and wet seasons.

```{r , warning= F , message=F}

# Merge the in degree for wet and dry season together.

Df = cbind(cypWet_Degree , cypDry_Degree)

# Assign column names.
names(Df) = c("In Degree - In Season", "In Degree - Dry Season")

# Create one unique identifier.

Df$Identifier <- seq.int(nrow(Df))

# Extract only those rows where the degrees do not match in wet and dry season.

Df = Df[which(Df[,1]!=Df[,2])]

Df = cbind(vertex_attr(CypWet, name="vertex.names", index =Df$Identifier) , Df[,1], Df[,2])

names(Df) = c("Animals", "In Degree - Wet Season", "In Degree - Dry Season")

Df

```

<span style="color:blue"> We can clearly see that alligators are listed and this is mainly attributed to the fact that alligators are important animals. Alligators generally hibernate during the winter months and their metabolism rate decreases. As a result of that we can see a change in degress between the wet and the season. 

#### Cypress Wetlands Dry & Wet Season Comparison - All Degree

```{r  warning= F , message=F , fig.width =16}

# Calculate the out degree.

cypDry_Degree = as.data.table(degree(CypDry, mode = "all"))

cypWet_Degree = as.data.table(degree(CypWet, mode = "all"))

# Plot the degree distribution.

Plot1 = ggplot(data=cypDry_Degree, aes(cypDry_Degree$V1)) + 
       geom_histogram(col = "black", fill= "violet") +
       theme_classic() +
       ggtitle("Cypress Wetlands Dry Season (All Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

Plot2 = ggplot(data=cypWet_Degree, aes(cypWet_Degree$V1)) + 
       geom_histogram(col = "black", fill= "violet") +
       theme_classic() +
       ggtitle("Cypress Wetlands Wet Season (All Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

# Use the library fucntion grid arrange to compare the graphs side by side.

grid.arrange(Plot1, Plot2, nrow = 1)


# Lets also see how the cumulative distribution looks like.

Deg_Dist_Dry = degree_distribution(CypDry, cumulative=T, mode="all")

Plot3 = plot( x=0:max(cypDry_Degree), y=1-Deg_Dist_Dry, pch=19, cex=1.2, col="orange", main ="Cypress Wetlands Dry Season (All Degree)",
xlab="Degree", ylab="Cumulative Frequency")

Deg_Dist_Wet = degree_distribution(CypWet, cumulative=T, mode="all")

Plot4 = plot( x=0:max(cypWet_Degree), y=1-Deg_Dist_Wet, pch=19, cex=1.2, col="blue", main ="Cypress Wetlands Wet Season (All Degree)",
xlab="Degree", ylab="Cumulative Frequency")


```

<span style="color:blue"> From the above shown in and out degree tables we can clearly see that the degrees of alligators change between the wet and dry season. Based on that finding we decided to plot out only the alligators and their "neighbours". By neighbours we mean those animals that are eaten by alligators and animals that eat alligators or their eggs. Undoubtedly, we expect to learn more about the reasons for the differences.

### Static Plot

```{r, fig.width=16, fig.height=10}

A = induced_subgraph(CypWet, c(23, neighbors(CypWet,23)))
B = induced_subgraph(CypDry, c(23, neighbors(CypDry,23)))

vertex_attr_names(A)

# Change the type from igraph to network

A = asNetwork(A)
B = asNetwork(B)

# Plot the network diagram

par(mfrow=c(1,2))

plot.network(B , label = network.vertex.names(B) , vertex.col = 3, edge.col = "red", vertex.cex = 5 , main = "Aligators Network (Dry Season)")

plot.network(A , label = network.vertex.names(A) , vertex.col = 3, edge.col = "red", vertex.cex = 5 , main = "Aligators Network (Wet Season)")
    
```

### Arc Diagram

```{r , fig.width=16, fig.height=10 , warning=F}

A = asIgraph(A)
ggraph(A, layout = "linear") + 
  geom_edge_arc(aes(col = "red"), alpha = 0.8 ) + 
  scale_edge_width(range = c(0.2, 2)) +
  geom_node_text(aes(label = V(A)$vertex.names), repel = TRUE) +
  labs(edge_width = "Connections of Aligators & Its Neighbours With Other Animals") +
  theme_graph()+
  ggtitle("Connections of Aligators & Its Neighbours With Other Animals")
  theme(legend.position = "bottom") 

```

<span style="color:blue"> The graph illustrates the importance of Vertebrate Det for alligators and many other animals. The connection between alligators and snakes shows that snakes eat alligator eggs and, alligators eat snakes and snake eggs. A similar pattern can be observed for turtles. We can conclude that controlling the population of snakes is key to control the population of alligators.

##  Centrality Measure 

<span style="color:blue"> In the next step we will extract a list of the top 10 animals based on the different centrality measures. This step will help us to define which animals eat many other kind of animals and which animals mainly serve as food for other animals.

### Out Degree Centrality - Dry Season

```{r}

# Calculate the out degree during the dry sesson

Cyp_Dry_Degree = data.table(degree(CypDry , mode = "out"))

# Creating a unique identifier.

Cyp_Dry_Degree$Identifier <- seq.int(nrow(Cyp_Dry_Degree))

# Ordering the data set in descending order based on out degree
setorder(Cyp_Dry_Degree, -V1)

# Extract top 20 page ids with highest out degree

TopAnimalsByOutDegree_Dry =Cyp_Dry_Degree[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByOutDegree_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByOutDegree_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByOutDegree_Dry$Identifier), TopAnimalsByOutDegree_Dry$V1))

# Assign column names
names(TopAnimalsByOutDegree_Dry) = c("Animal","Biomass" , "Out Degree Value")

# Display the result

TopAnimalsByOutDegree_Dry

```


### Out Degree Centrality - Wet Season


```{r}

# Calculate the out degree during the dry sesson

Cyp_Wet_Degree = data.table(degree(CypWet , mode = "out"))

# Creating a unique identifier

Cyp_Wet_Degree$Identifier <- seq.int(nrow(Cyp_Wet_Degree))

# Ordering the data set in descending order based on out degree
setorder(Cyp_Wet_Degree, -V1)

# Extract top 20 page ids with highest out degree

TopAnimalsByOutDegree_Wet =Cyp_Wet_Degree[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByOutDegree_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByOutDegree_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByOutDegree_Wet$Identifier), TopAnimalsByOutDegree_Wet$V1))

# Assign column names
names(TopAnimalsByOutDegree_Wet) = c("Animal","Biomass" , "Out Degree Value")

# Display the result

TopAnimalsByOutDegree_Wet

```

<span style="color:blue"> Central animals are those that have most out-links with other animals. Based on the above mentioned table we can conclude that Tertiary Invertebrates eat many different kind of other animals. This makes them less dependent on a single source of food. It deserves to mention that there are no significant differences between the dry and wet season in this case.

### In Degree Centrality - Dry Season

```{r}

# Calculate the in degree during the dry sesson

Cyp_Dry_Degree = data.table(degree(CypDry , mode = "in"))

# Creating a unique identifier.

Cyp_Dry_Degree$Identifier <- seq.int(nrow(Cyp_Dry_Degree))

# Ordering the data set in descending order based on in degree
setorder(Cyp_Dry_Degree, -V1)

# Extract top 20 page ids with highest in degree
# The top vertex with in degree is respiration. As it doesnot make sense to us we will exclude that. Probably a data entry error.As a result we will take the list from 2 to 11

TopAnimalsByInDegree_Dry =Cyp_Dry_Degree[,][2:11]

# Get the name of the animals along with their biomass

TopAnimalsByInDegree_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByInDegree_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByInDegree_Dry$Identifier), TopAnimalsByInDegree_Dry$V1))

# Assign column names
names(TopAnimalsByInDegree_Dry) = c("Animal","Biomass" , "In Degree Value")

# Display the result

TopAnimalsByInDegree_Dry

```


### In Degree Centrality - Wet Season


```{r}

# Calculate the in degree during the dry sesson

Cyp_Wet_Degree = data.table(degree(CypWet , mode = "in"))

# Creating a unique identifier.

Cyp_Wet_Degree$Identifier <- seq.int(nrow(Cyp_Wet_Degree))

# Ordering the data set in descending order based on in degree
setorder(Cyp_Wet_Degree, -V1)

# Extract top 20 page ids with highest in degree
# The top vertex with in degree is respiration. As it doesnot make sense to us we will exclude that. Probably a data entry error.As a result we will take the list from 2 to 11

TopAnimalsByInDegree_Wet =Cyp_Wet_Degree[,][2:11]

# Get the name of the animals along with their biomass

TopAnimalsByInDegree_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByInDegree_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByInDegree_Wet$Identifier), TopAnimalsByInDegree_Wet$V1))

# Assign column names
names(TopAnimalsByInDegree_Wet) = c("Animal","Biomass" , "In Degree Value")

# Display the result

TopAnimalsByInDegree_Wet

```

<span style="color:blue"> Based on the above mentioned table we can conclude that Vertebrate Det. serve as food for many different animals during the wet season as well as the dry season. The generally high values for turtles and alligators are probably a result of the fact that their eggs serve as food for other animals. Besides, young alligators and turtles also serve as food for many other animals throughout the year.

### All Degree Centrality - Dry Season

```{r}

# Calculate the all degree during the dry sesson.

Cyp_Dry_Degree = data.table(degree(CypDry , mode = "all"))

# Creating a unique identifier.

Cyp_Dry_Degree$Identifier <- seq.int(nrow(Cyp_Dry_Degree))

# Ordering the data set in descending order based on total degree
setorder(Cyp_Dry_Degree, -V1)

# Extract top 20 page ids with highest total degree
# The top vertex with in degree is respiration. As it doesnot make sense to us we will exclude that. Probably a data entry error.As a result we will take the list from 2 to 11

TopAnimalsByAllDegree_Dry =Cyp_Dry_Degree[,][2:11]

# Get the name of the animals along with their biomass

TopAnimalsByAllDegree_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByAllDegree_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByAllDegree_Dry$Identifier), TopAnimalsByAllDegree_Dry$V1))

# Assign column names
names(TopAnimalsByAllDegree_Dry) = c("Animal","Biomass" , "All Degree Value")

# Display the result

TopAnimalsByAllDegree_Dry

```


### All Degree Centrality - Wet Season

```{r}

# Calculate the all degree during the dry sesson.

Cyp_Wet_Degree = data.table(degree(CypWet , mode = "all"))

# Creating a unique identifier.

Cyp_Wet_Degree$Identifier <- seq.int(nrow(Cyp_Wet_Degree))

# Ordering the data set in descending order based on total degree
setorder(Cyp_Wet_Degree, -V1)

# Extract top 20 page ids with highest total degree
# The top vertex with in degree is respiration. As it doesnot make sense to us we will exclude that. Probably a data entry error.As a result we will take the list from 2 to 11

TopAnimalsByAllDegree_Wet =Cyp_Wet_Degree[,][2:11]

# Get the name of the animals along with their biomass

TopAnimalsByAllDegree_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByAllDegree_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByAllDegree_Wet$Identifier), TopAnimalsByAllDegree_Wet$V1))

# Assign column names
names(TopAnimalsByAllDegree_Wet) = c("Animal","Biomass" , "All Degree Value")

# Display the result

TopAnimalsByAllDegree_Wet

```

<span style="color:blue"> An overall high degree centrality indicates that an animal not only serves as food for other animals but also eats many other animals. Vertebrate Det. score very high on this dimension in both seasons. The high value of snakes can be attributed to the circumstance that their eggs and young snakes are eaten by many other animals throughout the year. A similar phenomena is shown for alligators. The unusual high change in the seasons for "Other herons" can be attributed to their travel patterns. For example, harons often leave cold places and move to warmer places to breed. Obviously, this pattern can lead to an increase in degrees in the dry season.

### Betweeness Centrality - Dry Season

```{r}
# Calculate the betweenness during the dry sesson

Cyp_Dry_Betweenness = data.table(betweenness(CypDry, directed = T))

# Creating a unique identifier.

Cyp_Dry_Betweenness$Identifier <- seq.int(nrow(Cyp_Dry_Betweenness))

# Ordering the data set in descending order based on degree
setorder(Cyp_Dry_Betweenness, -V1)

# Extract top 20 page ids with highest betweenness

TopAnimalsByBetweeness_Dry =Cyp_Dry_Betweenness[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByBetweeness_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByBetweeness_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByBetweeness_Dry$Identifier), TopAnimalsByBetweeness_Dry$V1))

# Assign column names
names(TopAnimalsByBetweeness_Dry) = c("Animal","Biomass" , "Betweeneess Value")

# Display the result

TopAnimalsByBetweeness_Dry

```


### Betweeness Centrality - Wet Season


```{r}
# Calculate the betweenness during the dry sesson

Cyp_Wet_Betweenness = data.table(betweenness(CypWet, directed = T))

# Creating a unique identifier.

Cyp_Wet_Betweenness$Identifier <- seq.int(nrow(Cyp_Wet_Betweenness))

# Ordering the data set in descending order based on degree
setorder(Cyp_Wet_Betweenness, -V1)

# Extract top 20 page ids with highest betweenness

TopAnimalsByBetweeness_Wet =Cyp_Wet_Betweenness[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByBetweeness_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByBetweeness_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByBetweeness_Wet$Identifier), TopAnimalsByBetweeness_Wet$V1))

# Assign column names
names(TopAnimalsByBetweeness_Wet) = c("Animal","Biomass" , "Betweeneess Value")

# Display the result

TopAnimalsByBetweeness_Wet

```

<span style="color:blue"> The betweeness centrality plays a crucial rule. For example, in this case a high betweeness centrality indicates the importance of an animal within its network. A high degree of betweeness means that an animal eats another animal and in turn is eaten by other animals. In short we can say that these animals help to maintain the stability of the ecosystem. If that animal goes extinct than this can have serious imlications on the network/underlying ecosystem. The very high value for Vertebrate Det. in both seasons illustrates its importance for the underlying network. The size of an animal does not determine the importance for its network but the betweeness centrality does.

### Eigen Vector Centrality - Dry Season


```{r}

# Calculate the eigen vector during the dry sesson.

Cyp_Dry_Eigen = eigen_centrality(CypDry, directed = T)
Cyp_Dry_Eigen = data.table(Cyp_Dry_Eigen$vector)

# Creating a unique identifier.

Cyp_Dry_Eigen$Identifier <- seq.int(nrow(Cyp_Dry_Eigen))

# Ordering the data set in descending order based on eigen vector
setorder(Cyp_Dry_Eigen, -V1)

# Extract top 20 page ids with highest eigen vector

TopAnimalsByEigen_Dry =Cyp_Dry_Eigen[,][2:11]

# Get the name of the animals along with their biomass

TopAnimalsByEigen_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByEigen_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByEigen_Dry$Identifier), TopAnimalsByEigen_Dry$V1))

# Assign column names
names(TopAnimalsByEigen_Dry) = c("Animal","Biomass" , "Eigen Centrality Value")

# Display the result

TopAnimalsByEigen_Dry

```


### Eigen Vector Centrality - Wet Season
 

```{r}

# Calculate the eigen vector during the dry sesson.

Cyp_Wet_Eigen = eigen_centrality(CypWet, directed = T)
Cyp_Wet_Eigen = data.table(Cyp_Wet_Eigen$vector)

# Creating a unique identifier.

Cyp_Wet_Eigen$Identifier <- seq.int(nrow(Cyp_Wet_Eigen))

# Ordering the data set in descending order based on eigen vector
setorder(Cyp_Wet_Eigen, -V1)

# Extract top 20 page ids with highest eigen vector

TopAnimalsByEigen_Wet =Cyp_Wet_Eigen[,][2:11]

# Get the name of the animals along with their biomass

TopAnimalsByEigen_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByEigen_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByEigen_Wet$Identifier), TopAnimalsByEigen_Wet$V1))

# Assign column names
names(TopAnimalsByEigen_Wet) = c("Animal","Biomass" , "Eigen Centrality Value")

# Display the result

TopAnimalsByEigen_Wet

```

<span style="color:blue"> Eigenvector centrality generalizes degree centrality by incorporating the importance of the neighbors. This helps
us to determine the "most important" animals for the network. The seasonsal changes could be a result of the breeding activities of relevant animals such as snakes and alligators. Nevertheless, Vertebrate Det is once again on top of the list. The consecutive top-ranking exemplifies its importance for the entire ecosystem. The high-ranking of alligators justifies our previous decision to conduct an in-depth evaluation of alligators.

### Closeness Centrality - Dry Season

```{r}
# Calculate the closeness during the dry sesson

Cyp_Dry_Closeness = data.table(closeness(CypDry))

# Creating a unique identifier.

Cyp_Dry_Closeness$Identifier <- seq.int(nrow(Cyp_Dry_Closeness))

# Ordering the data set in descending order based on closeness
setorder(Cyp_Dry_Closeness, -V1)

# Extract top 20 page ids with highest closeness

TopAnimalsByCloseness_Dry =Cyp_Dry_Closeness[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByCloseness_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByCloseness_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByCloseness_Dry$Identifier), TopAnimalsByCloseness_Dry$V1))

# Assign column names.
names(TopAnimalsByCloseness_Dry) = c("Animal","Biomass" , "Closeness Value")

# Display the result

TopAnimalsByCloseness_Dry

```


### Closeness Centrality - Wet Season

```{r}
# Calculate the closeness during the dry sesson

Cyp_Wet_Closeness = data.table(closeness(CypWet))

# Creating a unique identifier.

Cyp_Wet_Closeness$Identifier <- seq.int(nrow(Cyp_Wet_Closeness))

# Ordering the data set in descending order based on closeness
setorder(Cyp_Wet_Closeness, -V1)

# Extract top 20 page ids with highest closeness

TopAnimalsByCloseness_Wet =Cyp_Wet_Closeness[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByCloseness_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByCloseness_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByCloseness_Wet$Identifier), TopAnimalsByCloseness_Wet$V1))

# Assign column names.
names(TopAnimalsByCloseness_Wet) = c("Animal","Biomass" , "Closeness Value")

# Display the result

TopAnimalsByCloseness_Wet

```

<span style="color:blue"> In a connected graph, closeness centrality (or closeness) of a node is a measure of centrality in a network, calculated as the sum of the length of the shortest paths between the node and all other nodes in the graph. Thus the more central a node is, the closer it is to all other nodes. In other words we could say how easily an animal can interact with other animals in the network. We can only observe minor changes at the top of the list. Our findings support our previous findings and are in line with you expectations.

### Alpha Centrality - Dry Season

```{r}

# Calculate the alpha centrality during the dry sesson

Cyp_Dry_Alpha = data.table(alpha_centrality(CypDry))

# Creating a unique identifier.

Cyp_Dry_Alpha$Identifier <- seq.int(nrow(Cyp_Dry_Alpha))

# Ordering the data set in descending order based on alpha centrality
setorder(Cyp_Dry_Alpha, -V1)

# Extract top 20 page ids with highest alpha centrality

TopAnimalsByAlpha_Dry =Cyp_Dry_Alpha[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByAlpha_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByAlpha_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByAlpha_Dry$Identifier), TopAnimalsByAlpha_Dry$V1))

# Assign column names.
names(TopAnimalsByAlpha_Dry) = c("Animal","Biomass" , "Alpha Centrality Value")

# Display the result

TopAnimalsByAlpha_Dry

```


### Alpha Centrality - Wet Season

```{r}

# Calculate the alpha centrality during the dry sesson

Cyp_Dry_Wet = data.table(alpha_centrality(CypWet))

# Creating a unique identifier.

Cyp_Dry_Wet$Identifier <- seq.int(nrow(Cyp_Dry_Wet))

# Ordering the data set in descending order based on alpha centrality
setorder(Cyp_Dry_Wet, -V1)

# Extract top 20 page ids with highest alpha centrality

TopAnimalsByAlpha_Wet =Cyp_Dry_Wet[,][1:10]

# Get the name of the animals along with their biomass

TopAnimalsByAlpha_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByAlpha_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByAlpha_Wet$Identifier), TopAnimalsByAlpha_Wet$V1))

# Assign column names.
names(TopAnimalsByAlpha_Wet) = c("Animal","Biomass" , "Alpha Centrality Value")

# Display the result

TopAnimalsByAlpha_Wet

```

<span style="color:blue"> Alpha centrality is a measure of centrality of nodes within a graph. It is an adaptation of eigenvector centrality with the addition that nodes are imbued with importance from external sources. 

### Page Rank Centrality - Dry Season

```{r}

# Calculate the page rank centrality during the dry sesson

Cyp_Dry_PR = data.table(unlist(page_rank(CypDry, directed = T)))

# Creating a unique identifier.

Cyp_Dry_PR$Identifier <- seq.int(nrow(Cyp_Dry_PR))

# Ordering the data set in descending order based on degree
setorder(Cyp_Dry_PR, -V1)

# Extract top 20 page ids with highest page rank centrality

TopAnimalsByPageRank_Dry =Cyp_Dry_PR[,][3:12]

# Get the name of the animals along with their biomass

TopAnimalsByPageRank_Dry = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByPageRank_Dry$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByPageRank_Dry$Identifier), TopAnimalsByPageRank_Dry$V1))

# Assign column names.
names(TopAnimalsByPageRank_Dry) = c("Animal","Biomass" , "Page Rank Centrality Value")

# Display the result

TopAnimalsByPageRank_Dry

```


### Page Rank Centrality - Wet Season

```{r}

# Calculate the page rank centrality during the dry sesson

Cyp_Wet_PR = data.table(unlist(page_rank(CypWet, directed = T)))

# Creating a unique identifier.

Cyp_Wet_PR$Identifier <- seq.int(nrow(Cyp_Wet_PR))

# Ordering the data set in descending order based on degree
setorder(Cyp_Wet_PR, -V1)

# Extract top 20 page ids with highest page rank centrality

TopAnimalsByPageRank_Wet =Cyp_Wet_PR[,][3:12]

# Get the name of the animals along with their biomass

TopAnimalsByPageRank_Wet = data.table(cbind(vertex_attr(CypDry, name = "vertex.names",index =TopAnimalsByPageRank_Wet$Identifier),
vertex_attr(CypDry, name = "bio.masses...cypdry.dat",index =TopAnimalsByPageRank_Wet$Identifier), TopAnimalsByPageRank_Wet$V1))

# Assign column names.
names(TopAnimalsByPageRank_Wet) = c("Animal","Biomass" , "Page Rank Centrality Value")

# Display the result

TopAnimalsByPageRank_Wet

```

<span style="color:blue"> The key takeway from Page Rank Centrality is the following: An animal is important if it is pointed to by other important animals. As excpected, Vertebrate Det is once again on the top of the list. The differences between the wet and dry season can be attributed to the weather and the breeding habits. For example, Raccoons only appear on the Dry Season list. In general this can give as a good overview regarding the sensibility of an underlying ecosystem. For instance, massive changes in the population of Vertebrate Det can cause disbalances in the ecosystem. This knowledge helps to control and ensure the well-being of the ecosystem.

## Shiny App - Putting It All Together

<span style="color:blue"> In order to provide the Centrality measures found above in an interactive way we will create a shiny app which will provide the centrality measures in a tabular format based on interactivity. This option helps our stakeholders to have a closer look at animals and their roles. This app will provide our stakeholders with "detail on demand" which will ultimately translate into concrete actions to combat overpopulation.

<span style="color:orange"> This is the interactive map which will not work in the static version of the html file that has been uploaded. In order to use the filters interactively, please run the entire scripts in the local machine.

```{r, fig.height=30}

# Data preparation which will be supplied to the shiny server

setnames(TopAnimalsByOutDegree_Dry, old = "Out Degree Value", new = "Value")
TopAnimalsByOutDegree_Dry$Measure = "Out Degree"
TopAnimalsByOutDegree_Dry$Season = "Dry"

setnames(TopAnimalsByInDegree_Dry, old = "In Degree Value", new = "Value")
TopAnimalsByInDegree_Dry$Measure = "In Degree"
TopAnimalsByInDegree_Dry$Season = "Dry"

setnames(TopAnimalsByAllDegree_Dry, old = "All Degree Value", new = "Value")
TopAnimalsByAllDegree_Dry$Measure = "All Degree"
TopAnimalsByAllDegree_Dry$Season = "Dry"

setnames(TopAnimalsByBetweeness_Dry, old = "Betweeneess Value", new = "Value")
TopAnimalsByBetweeness_Dry$Measure = "Betweeness"
TopAnimalsByBetweeness_Dry$Season  = "Dry"

setnames(TopAnimalsByEigen_Dry, old = "Eigen Centrality Value", new = "Value")
TopAnimalsByEigen_Dry$Measure = "Eigen Centrality"
TopAnimalsByEigen_Dry$Season  = "Dry"

setnames(TopAnimalsByCloseness_Dry, old = "Closeness Value", new = "Value")
TopAnimalsByCloseness_Dry$Measure = "Closeness"
TopAnimalsByCloseness_Dry$Season  = "Dry"

setnames(TopAnimalsByAlpha_Dry, old = "Alpha Centrality Value", new = "Value")
TopAnimalsByAlpha_Dry$Measure = "Alpha Centrality"
TopAnimalsByAlpha_Dry$Season  = "Dry"

setnames(TopAnimalsByPageRank_Dry, old = "Page Rank Centrality Value", new = "Value")
TopAnimalsByPageRank_Dry$Measure = "Page Rank Centrality"
TopAnimalsByPageRank_Dry$Season  = "Dry"

setnames(TopAnimalsByOutDegree_Wet, old = "Out Degree Value", new = "Value")
TopAnimalsByOutDegree_Wet$Measure = "Out Degree"
TopAnimalsByOutDegree_Wet$Season = "Wet"

setnames(TopAnimalsByInDegree_Wet, old = "In Degree Value", new = "Value")
TopAnimalsByInDegree_Wet$Measure = "In Degree"
TopAnimalsByInDegree_Wet$Season = "Wet"

setnames(TopAnimalsByAllDegree_Wet, old = "All Degree Value", new = "Value")
TopAnimalsByAllDegree_Wet$Measure = "All Degree"
TopAnimalsByAllDegree_Wet$Season = "Wet"

setnames(TopAnimalsByBetweeness_Wet, old = "Betweeneess Value", new = "Value")
TopAnimalsByBetweeness_Wet$Measure = "Betweeness"
TopAnimalsByBetweeness_Wet$Season  = "Wet"

setnames(TopAnimalsByEigen_Wet, old = "Eigen Centrality Value", new = "Value")
TopAnimalsByEigen_Wet$Measure = "Eigen Centrality"
TopAnimalsByEigen_Wet$Season  = "Wet"

setnames(TopAnimalsByCloseness_Wet, old = "Closeness Value", new = "Value")
TopAnimalsByCloseness_Wet$Measure = "Closeness"
TopAnimalsByCloseness_Wet$Season  = "Wet"

setnames(TopAnimalsByAlpha_Wet, old = "Alpha Centrality Value", new = "Value")
TopAnimalsByAlpha_Wet$Measure = "Alpha Centrality"
TopAnimalsByAlpha_Wet$Season  = "Wet"

setnames(TopAnimalsByPageRank_Wet, old = "Page Rank Centrality Value", new = "Value")
TopAnimalsByPageRank_Wet$Measure = "Page Rank Centrality"
TopAnimalsByPageRank_Wet$Season  = "Wet"

# Merge all the dataset

Df= rbind(TopAnimalsByOutDegree_Dry,TopAnimalsByInDegree_Dry,TopAnimalsByAlpha_Dry, TopAnimalsByEigen_Dry,TopAnimalsByPageRank_Dry, TopAnimalsByAllDegree_Dry,TopAnimalsByBetweeness_Dry , TopAnimalsByCloseness_Dry,TopAnimalsByOutDegree_Wet,TopAnimalsByInDegree_Wet,TopAnimalsByAlpha_Wet, TopAnimalsByEigen_Wet,TopAnimalsByPageRank_Wet, TopAnimalsByAllDegree_Wet,TopAnimalsByBetweeness_Wet , TopAnimalsByCloseness_Wet)

# Define the user interface 

ui = fluidPage(
  titlePanel("This is an Interactive Shiny App"),
  sidebarLayout(
    sidebarPanel(
      selectInput("Measure", "Select the Type of Centrality Measure", choices = Df$Measure , selected = 2),
      selectInput("Season", "Select the Type of Season", choices = Df$Season, selected =2)
    ),
  mainPanel("Here is the Required Data", style = "font-size:120%; width:50%",
    tableOutput("Df")
  )
  )
)


# Define the server logic

server = function(input, output) {
  output$Df = renderTable({
    MeasureFilter = subset(Df, Df$Measure == input$Measure & Df$Season ==input$Season)
  })
    
  }
  
# Run the application 
shinyApp(ui = ui, server = server)

```

## Transitivity & Reciprocity

<span style="color:blue"> The basic concept of transitivity is when "a friend of my friend is my friend". Applied to our case we can say that "the food of my food regards me as food". We will now compare the global and local clustering coefficients between the Dry and Wet seasons in south Florida.

```{r , fig.width=16, fig.height=10 , warning=F}

# Global transitivity

transitivity(graph = CypDry , type= "global")

transitivity(graph = CypWet , type= "global")

# local transitivity

transitivity(graph = CypDry , type= "localaverage")

transitivity(graph = CypWet , type= "localaverage")

```

<span style="color:blue"> Although there is not much difference between the global and local clustering coefficent value in the dry and wet seasons, it can be inferred that the Dry seasons have a slightly greater "global clustering coefficient" than the Wet seasons. Nevertheless, the "local clustering coefficient" is less.  Since the values for transitivity range around 0.5 we can conclude that we are dealing with a non-random network. Undoubtedly, this finding is important for our stakeholders because it helps to generalize findings.

```{r , fig.width=16, fig.height=10 , warning=F}

reciprocity(graph = CypDry , mode= "ratio")

reciprocity(graph = CypWet , mode= "ratio")


reciprocity(graph = CypDry , mode= "default")

reciprocity(graph = CypWet , mode= "default")


```

## Network Modelling

### Erdos Reyni Model (Random Network)

<span style="color:orange"> We will build the Erdos Reyni Model, with the same proportion as we have in the original model. In this excercise we will only compare the "in degree" between the original with the Erdos Reyni Model. 

```{r ,fig.width=16}

# Lets first calculate the proportion of vertices and edges in the original graph


proportion = vcount(CypDry) / ecount(CypDry)

proportion

# Calculate Erdos Reyni model

Dry_ER = erdos.renyi.game(n= vcount(CypDry), directed = T, loops = F, p.or.m = proportion)

# Histogram of the plot and comparing it with original model

Plot1 = ggplot(data=as.data.table(degree(CypDry, mode= "in")), aes(as.data.table(degree(CypDry, mode= "in"))$V1)) + 
       geom_histogram(col = "black", fill= "violet") +
       theme_classic() +
       ggtitle("Cypress Wetlands Dry Season (In Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

Plot2 = ggplot(data=as.data.table(degree(Dry_ER, mode= "in")),            aes(as.data.table(degree(Dry_ER, mode= "in"))$V1)) + 
       geom_histogram(col = "black", fill= "turquoise") +
       theme_classic() +
       ggtitle("Erdos Reyni Model Dry Season (In Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

# Use the library fucntion grid arrange to compare the graphs side by side.

grid.arrange(Plot1, Plot2, nrow = 1)


# Plot the Erdos Renyi Model

plot(Dry_ER, layout=layout.circle)


# Increase the proportion and compare how the Erdos Reyni model looks like

Dry_ER_75 = erdos.renyi.game(n= vcount(CypDry), directed = T, loops = F, p.or.m = .75)

Dry_ER_50 = erdos.renyi.game(n= vcount(CypDry), directed = T, loops = F, p.or.m = .50)

# Histogram of the plot and comparing it with original model

Plot3 = ggplot(data=as.data.table(degree(Dry_ER_75, mode= "in")), aes(as.data.table(degree(Dry_ER_75, mode= "in"))$V1)) + 
       geom_histogram(col = "black", fill= "violet" , bins = 10) +
       theme_classic() +
       ggtitle("Cypress Wetlands Dry Season (Proportion - 75)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

Plot4 = ggplot(data=as.data.table(degree(Dry_ER_50, mode= "in")),            aes(as.data.table(degree(Dry_ER_50, mode= "in"))$V1)) + 
       geom_histogram(col = "black", fill= "turquoise" ,bins =10) +
       theme_classic() +
       ggtitle("Erdos Reyni Model Dry Season (Proportion - 50)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

# Use the library fucntion grid arrange to compare the graphs side by side.

grid.arrange(Plot3, Plot4, nrow = 1)


```

<span style="color:blue"> The study  of  random  networks  reached  prominence  thanks  to  the  fundamental work of Pl Erdos and Alfrd Rnyi. Undoubtedly, our findings support the assumption that the newtork is not random.

## Watts Strogatz Model (Small World Network)

<span style="color:orange"> We will now create another network model using the watts strogatz game. The probability will be the same as the proportion of the original graph and we will use total number of vertices in the original graph as the size.

```{r , fig.width=16}

Dry_WS = watts.strogatz.game(dim = 1,size =vcount(CypDry),nei = 5, p = proportion)

# Histogram of the plot and comparing it with original model

Plot5 = ggplot(data=as.data.table(degree(CypDry, mode= "in")), aes(as.data.table(degree(CypDry, mode= "in"))$V1)) + 
       geom_histogram(col = "black", fill= "violet") +
       theme_classic() +
       ggtitle("Cypress Wetlands Dry Season (In Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

Plot6 = ggplot(data=as.data.table(degree(Dry_WS, mode= "in")),            aes(as.data.table(degree(Dry_WS, mode= "in"))$V1)) + 
       geom_histogram(col = "black", fill= "turquoise") +
       theme_classic() +
       ggtitle("Watts Strogatz Model Dry Season (In Degree)")  +
        xlab("Number of Degrees") +
        ylab("Frequency")

# Use the library fucntion grid arrange to compare the graphs side by side.

grid.arrange(Plot5, Plot6, nrow = 1)


# Plot the Watts Strogatz Model

plot(Dry_WS, layout=layout.circle)

```

<span style="color:blue"> The model of Watts and Strogatz is important because it shows how the "small-world effect" in networks can coexist with other commonly observed features of social networks, like a high clustering coefficient.  More specifically, the model showed how adding a small fraction of random long-range links in an otherwise regular network can lead to slow, logarithmic scaling of the typical distance between nodes with network size. Beginning with the circle network, they randomly rewired each link with probability p. Thus, in the limit where p???1, the model approaches a fully random network. Our findings support the assumption of a small world-network.

## Comparison Erdos Reyni VS Watts Strogatz Model

```{r , fig.width=16}
# Lets startup by ploting the distribution of both the models

grid.arrange(Plot2 , Plot6 , nrow = 1)

# Compare the plot

par(mfrow=c(1,2))


plot(Dry_ER, layout=layout.circle , main = "Erdos Reyni Model")

plot(Dry_WS, layout=layout.circle, main = "Watts Strogatz Model")

# Average path length value

AvgPath = cbind("Average Path length", average.path.length(Dry_ER), average.path.length(Dry_WS))

# Diameter value

Dia = cbind("Diameter", diameter(Dry_ER), diameter(Dry_WS))

# Global transitivity

GTrans = cbind("Global Transitivity", transitivity(Dry_ER , type ="global"), transitivity(Dry_WS , type="global"))

# local transitivity

LTrans = cbind("Local Transitivity", transitivity(Dry_ER , type ="localaverage"), transitivity(Dry_WS , type="localaverage"))


# Mean in degree 

MeanInDeg = cbind("Mean In Degree", mean(degree(Dry_ER , mode="in")), mean(degree(Dry_WS, mode= "in")))


# Mean out degree 

MeanOutDeg = cbind("Mean Out Degree", mean(degree(Dry_ER , mode="out")), mean(degree(Dry_WS, mode= "out")))

# Median in degree

MedianInDeg = cbind("Median In Degree", median(degree(Dry_ER , mode="in")), median(degree(Dry_WS, mode= "in")))


# Median out degree 

MedianOutDeg = cbind("Median Out Degree", median(degree(Dry_ER , mode="out")), median(degree(Dry_WS, mode= "out")))

# Standard deviation of in degree

SdInDeg = cbind("Standard deviation In Degree", sd(degree(Dry_ER , mode="in")), sd(degree(Dry_WS, mode= "in")))


# Standard deviation out degree 

SdOutDeg = cbind("Standard deviation Out Degree", sd(degree(Dry_ER , mode="out")), sd(degree(Dry_WS, mode= "out")))


ComparisionTable = as.data.table(rbind(MeanInDeg,MeanOutDeg,MedianInDeg,MedianOutDeg,SdInDeg,SdOutDeg, Dia,AvgPath,GTrans,LTrans))

# Assigning column names

names(ComparisionTable) = c("Measures","ER Model Value" , "WS Model Value") 

```

### Model Comparison Table

```{r}

# Display result

ComparisionTable

```


## Power Law 

<span style="color:blue"> Let us now see if the degree distribution of the Erdos Reyni model or the Watts Strogatz model follow a power law. To check the power law we will work only with the "in degree" centrality.

```{r}

# Plot the degree distribution of the WS model

Deg_Dist_Dry_WS= degree_distribution(Dry_WS, cumulative=T, mode="in")

probability = Deg_Dist_Dry_WS[-1]

# Delete blank values


nonzero.position= which(probability != 0)
probability = probability[nonzero.position]
degree = 1:max(degree(Dry_WS))
degree = degree[nonzero.position]

# Fit of degree distribution

reg= lm(log(probability) ~ log(degree))
summary(reg)$r.square
cozf= coef(reg)

# Plot the distribution


plot(probability ~degree , main ="Watts Strogatz Model Probablistic Distribution")


# Plot the degree distribution of the WS model

Deg_Dist_Dry_ER= degree_distribution(Dry_ER, cumulative=T, mode="in")

probability = Deg_Dist_Dry_ER[-1]

# Delete blank values


nonzero.position= which(probability != 0)
probability = probability[nonzero.position]
degree = 1:max(degree(Dry_ER))
degree = degree[nonzero.position]

# Fit of degree distribution

reg= lm(log(probability) ~ log(degree))
summary(reg)$r.square
cozf= coef(reg)

# Plot the distribution


plot(probability ~degree , main ="Erdos Reyni Model Probablistic Distribution")

```

<span style="color:blue"> The Erdos Reyni plot distribution almost follows a power law.

## Community Detection

<span style="color:blue"> We want to cluster the animals into different communities so that we can tackle a problem from a community perspective and not an individual one. Community detection is crucial in order to understand the interaction between various clusters. We explored various algortihms (shown below) to determine the right amount of communities. The filter option helps our stakeholders to 
select the community of interest in a fast and efficient manner.

### Algorithm : Walk trap

```{r}

# Subset the dataset

Animals = induced_subgraph(CypWet, c(1:66))

# Run clustering with walk trap algorithm

WT = walktrap.community(Animals, modularity=TRUE, steps =7)

# Assign the communities to the members

V(Animals)$community <- WT$membership

# Modularity of the algorithm

modularity(WT)

# Prepare the edges for the visualization

nodes <- data.frame(id = V(Animals)$vertex.names, title = V(Animals)$vertex.names, group = V(Animals)$community)
nodes <- nodes[order(nodes$id, decreasing = F),]
nodes$A = seq(nrow(nodes))

# Prepare the edges for the visualization

edges <- get.data.frame(Animals, what="edges")[1:2]
edges$from =nodes$id[match(edges$from,nodes$A)]
edges$to =nodes$id[match(edges$to,nodes$A)]

# Display the visualization

visNetwork(nodes, edges , main ="Communiuty Detection Using Walk Trap") %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visGroups(groupname = "A", color = "red", shape = "triangle")


# Lets check the distribution of the number of vertices in the group

hist(WT$membership , col = "green" 
     , main = "Distribution of Number of Vertices in the Clusters"
     , xlab = "Cluster Numbers"
     , ylab = "Frequecy" , breaks  =9)


# Get the absolute number

table(WT$membership)

```

#### Modularity Optimization

<span style="color:orange"> Changing the hyper parameters increases or decreases the modularity. Depending upon wheter you want randomness or not you can choose any one of the following hyperparameters. Let us compare the walk trap with different random walks.

```{r}

set.seed(6497)

Iter1 = modularity(walktrap.community(Animals, modularity=TRUE, steps =2))

Iter2 = modularity(walktrap.community(Animals, modularity=TRUE, steps =3))

Iter3 = modularity(walktrap.community(Animals, modularity=TRUE, steps =4))

Iter4 = modularity(walktrap.community(Animals, modularity=TRUE, steps =5))

Iter5 = modularity(walktrap.community(Animals, modularity=TRUE, steps =6))

Iter6 = modularity(walktrap.community(Animals, modularity=TRUE, steps =7))

Iter7 = modularity(walktrap.community(Animals, modularity=TRUE, steps =8))

# Display the modularity of the various iterations

cbind(Iter1,Iter2,Iter3,Iter4,Iter5,Iter6, Iter7)


Df = melt(cbind(Iter1,Iter2,Iter3,Iter4,Iter5,Iter6, Iter7))

# Modularity Optimization

plot(x=Df$Var2,y= Df$value , main="Modularity of Different Iterations"
     , ylab= "Modularity Value"
     , xlab="Different Iterations")


```

<span style="color:orange"> The above shown graph helps us to determine the right parameter to get a high or low modularity. 

<span style="color:orange"> It can be inferred that Iteration 1 with random walks of value 2 provides the lowest modurality, whereas the iteration 5 with a random walk of 6 provides the highest modularity.

### Algorithm : Fast Greedy

```{r}

# Subset the dataset

Animals = induced_subgraph(CypWet, c(1:66))

# Run clustering with walk trap algorithm

IM = cluster_infomap(Animals)

# Assign the communities to the members

V(Animals)$community <- IM$membership

# Modularity of the algorithm

modularity(IM)

# Prepare the edges for the visualization

nodes <- data.frame(id = V(Animals)$vertex.names, title = V(Animals)$vertex.names, group = V(Animals)$community)
nodes <- nodes[order(nodes$id, decreasing = F),]
nodes$A = seq(nrow(nodes))

# Prepare the edges for the visualization

edges <- get.data.frame(Animals, what="edges")[1:2]
edges$from =nodes$id[match(edges$from,nodes$A)]
edges$to =nodes$id[match(edges$to,nodes$A)]

# Display the visualization

visNetwork(nodes, edges , main ="Communiuty Detection Using Walk Trap") %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visGroups(groupname = "A", color = "red", shape = "triangle")


# Lets check the distribution of the number of vertices in the group

hist(IM$membership , col = "blue" 
     , main = "Distribution of Number of Vertices in the Clusters"
     , xlab = "Cluster Numbers"
     , ylab = "Frequecy" , breaks  =3)


# Get the absolute number

table(IM$membership)

```

<span style="color:orange"> Unfortunately, this algorithm does not perform that well, as it clusters almost all the animals in one cluster and only one animal in the other cluster. This does not provide any meaningful insights for our stakeholders.

## Conclusion

<span style="color:blue"> The objective of our analysis was to provide insights for our stakeholders (e.g. governments, NGOs, etc.) so that they can streamline their activites. Based on that we created a kind of interactive tool to extract meaningful insights. We want to provide this tool to our target audience so they can use it in their daily work and update it with the latest datasets. Undoubtedly, further information in the data-set could have helped us to further comment on information diffusion. Nevertheless, the limited information on that topic made it challenging to extract meaningful insights. Our work will help our stakeholders to take faster and more customized actions in regards to endangered species, overpooulation of animals and the spead of animal diseases. Global warming forces us to take action in these areas and our work is a contribution to our obligations.
